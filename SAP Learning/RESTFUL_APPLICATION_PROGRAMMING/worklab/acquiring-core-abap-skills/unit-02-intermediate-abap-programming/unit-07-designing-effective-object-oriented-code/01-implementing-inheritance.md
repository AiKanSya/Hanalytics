# ğŸŒ¸ 1 [IMPLEMENTING INHERITANCE](https://learning.sap.com/learning-journeys/acquire-core-abap-skills/implementing-inheritance_bfdb59f7-0f99-48b9-b019-a7b766830ecc)

> ğŸŒº Objectifs
>
> - [ ] Vous pourrez implÃ©menter une classe spÃ©cialisÃ©e

## ğŸŒ¸ INHERITANCE IMPLEMENTATION

Regardez cette vidÃ©o pour comprendre le concept de cours gÃ©nÃ©raux et plus spÃ©cialisÃ©s.

[RÃ©fÃ©rence - Link VidÃ©o](https://learning.sap.com/learning-journeys/acquire-core-abap-skills/implementing-inheritance_bfdb59f7-0f99-48b9-b019-a7b766830ecc)

### INHERITANCE - THE "IS A" RELATIONSHIP

En modÃ©lisation, on parle de spÃ©cialisation. L'implÃ©mentation de cette relation dans un langage de programmation utilise le concept d'hÃ©ritage, oÃ¹ une nouvelle classe (la sous-classe) dÃ©rive d'une classe existante (la superclasse). Un test fiable pour vÃ©rifier l'existence d'une vÃ©ritable relation d'hÃ©ritage entre deux classes consiste Ã  direÂ : Â«Â une sous-classe est une superclasseÂ Â». Si c'est clairement le cas, il existe une relation d'hÃ©ritage. Si c'est manifestement faux, ou mÃªme si cela semble Ã©trange, il n'y a pas de relation d'hÃ©ritage et il ne faut pas en implÃ©menter une, car cela risque de poser des problÃ¨mes ultÃ©rieurement. En testant notre modÃ¨le, nous pouvons affirmer sans Ã©quivoque qu'Â«Â un avion cargo est un avionÂ Â» et qu'Â«Â un avion de ligne est un avionÂ Â».

![](./assets/DefiningInheritance_002.png)

Une classe qui hÃ©rite d'une superclasse contient automatiquement tous les composants de cette superclasse. Par exemple, la classe Â«Â avion de ligneÂ Â» possÃ¨de un constructeur et un type, tout comme un avion. Cela n'est pas surprenant, car un avion de ligne est un avion. Ce qui peut paraÃ®tre surprenant Ã  premiÃ¨re vue, c'est que la classe Â«Â avion de ligneÂ Â» ne peut pas accÃ©der Ã  ses propres constructeur et type. En effet, ce sont des attributs privÃ©s de la superclasse et, par consÃ©quent, inaccessibles Ã  la sous-classe. Vous dÃ©couvrirez plus loin comment permettre Ã  une sous-classe d'accÃ©der aux composants d'une superclasse sans les rendre entiÃ¨rement publics.

### DEFINING THE INHERITANCE RELATIONSHIP

En ABAP, l'hÃ©ritage est implÃ©mentÃ© Ã  l'aide de l'ajout `INHERITING FROM` dans l'instruction de dÃ©finition de classe. Dans cet exemple, la classe avion de passagers est dÃ©finie comme une sous-classe de la classe avion. Notez que la sous-classe connaÃ®t sa super-classe, mais la classe avion ignore ses sous-classes (le cas Ã©chÃ©ant).

![](./assets/DefiningInheritance_003.png)

Une sous-classe ne peut avoir qu'une seule superclasse directe.

### ONE SUPERCLASS - ANY NUMBER OF SUBCLASSES

La classe plane peut avoir n'importe quel nombre de sous-classes, mais elle n'en connaÃ®t aucune.

![](./assets/DefiningInheritance_004.png)

Chaque sous-classe possÃ¨de une seule superclasse directe. Elle connaÃ®t sa superclasse, mais ignore ses classes sÅ“urs (autres classes dÃ©rivÃ©es de la mÃªme superclasse). Dans notre exemple, la classe des avions de passagers ignore l'existence de la classe des avions cargo.

### HOW TO EXTEND A SUBCLASS

![](./assets/DefiningInheritance_005.png)

Une fois une sous-classe dÃ©clarÃ©e, vous devez y ajouter de nouveaux composants ou modifier les composants existants. C'est ainsi que la simple copie de la classe avion devient un avion de ligne ou un avion cargo. GrÃ¢ce Ã  l'hÃ©ritage, inutile d'implÃ©menter la classe de A Ã  ZÂ ; il suffit de l'Ã©tendre avec les nouveaux composants nÃ©cessaires.

Il existe trois faÃ§ons de procÃ©derÂ :

#### ğŸ’® **Add new components** :

Vous pouvez dÃ©clarer de nouveaux attributs, types, constantes et mÃ©thodes dans la classe. Leurs noms ne doivent pas entrer en conflit avec ceux dÃ©jÃ  utilisÃ©s pour dÃ©clarer des composants dans la superclasse. Vous devez Ã©galement vous assurer que les nouveaux composants ne concernent que la sous-classe, et non toutes ses spÃ©cialisations. Si vous dÃ©clarez un nouvel attribut ou une nouvelle mÃ©thode gÃ©nÃ©ralement pertinente, vous devez la dÃ©placer dans la superclasse.

#### ğŸ’® **Redefine methods** :

RedÃ©finir les mÃ©thodesÂ : Lorsque vous appelez une mÃ©thode hÃ©ritÃ©e, le systÃ¨me d'exÃ©cution exÃ©cute l'implÃ©mentation de la mÃ©thode depuis la superclasse. Cependant, cette implÃ©mentation ne peut pas prendre en compte les nouveaux composants dÃ©clarÃ©s dans la sous-classe. Dans ce cas, vous pouvez redÃ©finir la mÃ©thode. Cela signifie que vous pouvez lui attribuer une nouvelle implÃ©mentation pertinente pour la sous-classe.

#### ğŸ’® **Add a new constructor** :

Ajouter un nouveau constructeurÂ : Les constructeurs garantissent l'initialisation correcte des nouvelles instances de la classe. Lors de la crÃ©ation d'une instance d'une sous-classe, le systÃ¨me d'exÃ©cution exÃ©cute toujours le constructeur de la superclasse. Cela garantit, par exemple, qu'un avion de ligne possÃ¨de un constructeur et un type, comme tout autre avion. Cependant, le constructeur de la superclasse ne peut pas initialiser les attributs de la sous-classe, car il ignore leur existence. C'est pourquoi vous pouvez dÃ©finir un nouveau constructeur pour la sous-classe.

### DECLARING NEW COMPONENTS

![](./assets/DefiningInheritance_006.png)

Vous pouvez Ã©tendre une sous-classe en dÃ©clarant de nouveaux composants. Ceux-ci sont visibles par la classe elle-mÃªme, mais pas par la superclasse, ni par les autres classes hÃ©ritant de la mÃªme superclasse. Il faut donc dÃ©terminer si les nouveaux composants sont uniquement pertinents pour la classe actuelle ou s'ils doivent Ãªtre dÃ©clarÃ©s dans la superclasse.

### PROTECTED COMPONENTS

MÃªme si une sous-classe contient tous les attributs de sa superclasse, elle n'est pas autorisÃ©e Ã  accÃ©der directement aux composants privÃ©s. Cela est parfois nÃ©cessaire, mais il arrive aussi qu'une superclasse doive autoriser ses sous-classes Ã  accÃ©der Ã  des attributs ou mÃ©thodes particuliers sans les rendre entiÃ¨rement publics. Elle peut le faire en les dÃ©clarant dans la section protÃ©gÃ©e. Les composants protÃ©gÃ©s sont visibles au sein de la classe elle-mÃªme, mais aussi par toutes les sous-classes.

![](./assets/DefiningInheritance_007.png)

Dans la dÃ©finition de classe, vous introduisez la section protÃ©gÃ©e Ã  l'aide de l'instruction `PROTECTED SECTION`. Vous devez toujours dÃ©clarer les sections de visibilitÃ© selon la sÃ©quenceÂ : `PUBLIC SECTION` - `PROTECTED SECTION` - `PRIVATE SECTION`.

Vous pouvez dÃ©placer un composant existant d'une classe Ã  l'aide d'un correctif rapide. Pour ce faire, placez le curseur sur le nom du composant dans ADT et appuyez sur [Ctrl] + [1], puis choisissez le correctif rapide `make <element> protected`.

DÃ©placer un composant privÃ© vers la section protÃ©gÃ©e est une modification compatibleÂ : vous avez Ã©largi la visibilitÃ© du composant. En revanche, protÃ©ger un composant public est une modification incompatible et peut entraÃ®ner des erreurs de syntaxe. En effet, vous avez restreint la visibilitÃ© du composant, qui a peut-Ãªtre dÃ©jÃ  Ã©tÃ© utilisÃ© en dehors de la hiÃ©rarchie d'hÃ©ritage.

### REDEFINING METHODS

Les superclasses contiennent souvent des mÃ©thodes que vous souhaitez utiliser dans une sous-classe, mais leurs implÃ©mentations sont inadaptÃ©es car elles ne prennent pas en compte la nature particuliÃ¨re de la sous-classe. Par exemple, la mÃ©thode `get_attributes` de la classe plane ne peut pas renvoyer les attributs dÃ©finis dans la classe passenger plane. Cependant, cette derniÃ¨re nÃ©cessite tout de mÃªme une mÃ©thode `get_attributes`.

![](./assets/DefiningInheritance_008.png)

En ABAP, vous pouvez rÃ©soudre ce problÃ¨me en redÃ©finissant la mÃ©thode d'instance get_attributes. Lorsque vous redÃ©finissez une mÃ©thode, vous Ã©crivez une nouvelle implÃ©mentation dans la sous-classe, prenant en compte des Ã©lÃ©ments que seule la sous-classe peut connaÃ®tre. Cependant, la dÃ©finition de la mÃ©thode reste identique. Vous devez suivre les rÃ¨gles suivantesÂ :

- La mÃ©thode conserve le mÃªme nom.

- Vous indiquez que vous souhaitez redÃ©finir la mÃ©thode en la dÃ©clarant dans la sous-classe avec l'ajout REDEFINITION.

- La mÃ©thode a la mÃªme visibilitÃ© que dans la super-classe.

- Vous ne devez pas modifier la signature de la mÃ©thode.

- Vous ne pouvez pas redÃ©finir une mÃ©thode statique.

### IMPLEMENTING THE REDEFINITION

Lorsque vous implÃ©mentez la redÃ©finition d'une mÃ©thode, vous pouvez appeler l'implÃ©mentation dans la superclasse. Pour ce faire, utilisez la rÃ©fÃ©rence d'objet implicite super, qui pointe vers la superclasse dans l'instance courante. De cette faÃ§on, vous pouvez rÃ©utiliser l'implÃ©mentation de la mÃ©thode de la superclasse et l'enrichir dans votre propre implÃ©mentation.

![](./assets/DefiningInheritance_009.png)

Il n'est pas nÃ©cessaire de dÃ©clarer la variable de rÃ©fÃ©rence super. Elle est automatiquement disponible lors de l'implÃ©mentation des mÃ©thodes redÃ©finies.

Appeler la mÃ©thode dans la superclasse de cette maniÃ¨re est facultatif. Parfois, c'est une bonne idÃ©e, parfois, cela n'apporte rien.

### NEW CONSTRUCTOR DEFINITION

![](./assets/DefiningInheritance_010.png)

Dans une sous-classe, vous pouvez dÃ©finir un nouveau constructeur. Contrairement aux redÃ©finitions de mÃ©thodes, un constructeur peut avoir sa propre signature. La signature d'un constructeur contient souvent les mÃªmes paramÃ¨tres que le constructeur de la superclasse, ainsi que ses propres paramÃ¨tres. En effet, le nouveau constructeur d'instance a deux tÃ¢chesÂ : d'abord, appeler le constructeur de la superclasse, puis initialiser ses propres attributs spÃ©cifiques Ã  la sous-classe.

Outre la dÃ©finition d'un nouveau constructeur, vous pouvez Ã©galement dÃ©finir un nouveau constructeur statique dans une sous-classe.

### ROLE OF THE CONSTRUCTOR

The constructor of a subclass has two functions; it must ensure that the instance of the superclass is properly created, and after that, it can set the initial values of its own attributes.

![](./assets/DefiningInheritance_011.png)

Dans notre exemple, puisqu'un avion de ligne est un avion, il ne peut y avoir d'instance d'avion de ligne tant que le constructeur de la classe avion n'a pas dÃ©fini le constructeur et le type du nouvel avion de ligne. Ce n'est qu'aprÃ¨s cela que la classe avion de ligne peut dÃ©finir ses propres attributs.

Le constructeur de la sous-classe doit donc pouvoir dÃ©finir non seulement ses propres attributs, mais aussi transmettre les valeurs requises au constructeur de la superclasse. C'est pourquoi la signature du constructeur de la sous-classe contient souvent la signature complÃ¨te du constructeur qu'il doit appeler.

### SEQUENCE OF NEW CONSTRUCTOR IMPLEMENTION

![](./assets/DefiningInheritance_012.png)

Lors de l'implÃ©mentation du nouveau constructeur, une sÃ©quence d'opÃ©rations particuliÃ¨re doit Ãªtre respectÃ©e. L'Ã©vÃ©nement le plus important est l'appel au constructeur de la superclasse. Cet appel est obligatoire et la mÃ©thode est appelÃ©e Ã  l'aide de la rÃ©fÃ©rence implicite super, comme lors de l'appel de l'implÃ©mentation originale d'une mÃ©thode redÃ©finie. LÃ  encore, il n'est pas nÃ©cessaire de dÃ©clarer explicitement super.

Avant d'appeler le constructeur de la superclasse, vous ne devez pas adresser les composants d'instance de l'instance en cours de construction. Vous pouvez adresser les composants statiques de la classe et vÃ©rifier l'exactitude des paramÃ¨tres d'importation du constructeur. S'ils sont incorrects, gÃ©nÃ©rez une exception.

Une fois le constructeur de la superclasse exÃ©cutÃ© avec succÃ¨s, vous pouvez adresser les composants d'instance de votre nouvelle instance.

### SEQUENCE OF CONSTRUCTOR CALLS

La figure illustre la sÃ©quence d'appel des constructeurs statiques et d'instance. L'exemple suppose qu'un programme souhaite instancier la classe d'avion de passagers et que celle-ci n'a pas encore Ã©tÃ© traitÃ©e.

![](./assets/DefiningInheritance_013.png)

Lorsque le programme tente de crÃ©er une instance de la classe d'avion de passagers, le systÃ¨me d'exÃ©cution appelle automatiquement les constructeurs statiques sÃ©quentiellement, en commenÃ§ant par le haut de la hiÃ©rarchie d'hÃ©ritage. Une fois tous les constructeurs statiques exÃ©cutÃ©s, le systÃ¨me d'exÃ©cution appelle le constructeur d'instance de la sous-classe, qui appelle Ã  son tour le constructeur d'instance de la superclasse.

### USING ABSTRACT AND FINAL COMPONENTS

![](./assets/AbstractandFinal_001.png)

Vous pouvez dÃ©clarer une classe comme abstraite. Cela signifie qu'un programme ne peut pas l'instancier. Dans notre exemple avec les avions, les avions de ligne et les avions cargo, vous pourriez dÃ©cider que, dans le monde rÃ©el, il n'existe que des avions de ligne et des avions cargo. Cependant, du point de vue de la modÃ©lisation logicielle, il est utile d'avoir la classe lcl_plane pour contenir les composants communs aux avions cargo et aux avions de ligne. En utilisant la classe abstraite, vous pouvez implÃ©menter tous les composants communs de la classe plane sans craindre que quelqu'un ne crÃ©e des instances de la classe par erreur.

Si une classe est abstraite, vous pouvez toujours accÃ©der Ã  ses composants statiques. Ce sontÂ :

- MÃ©thodes statiques

- Attributs statiques

- Constantes

- DÃ©finitions de type

![](./assets/AbstractandFinal_002.png)

Bien qu'il soit possible d'implÃ©menter les mÃ©thodes d'une classe abstraite, vous pouvez Ã©galement dÃ©clarer une mÃ©thode individuelle comme abstraite. Dans ce cas, elle n'est pas implÃ©mentÃ©e dans la classe oÃ¹ elle est dÃ©clarÃ©e. Notez que vous ne pouvez dÃ©clarer une mÃ©thode abstraite que dans une classe abstraite.

Les sous-classes de la classe abstraite ne peuvent Ãªtre instanciÃ©es qu'une fois la mÃ©thode abstraite redÃ©finie.

![](./assets/AbstractandFinal_003.png)

Vous pouvez dÃ©clarer une classe comme FINALE. Cela signifie qu'elle ne peut pas avoir de sous-classes.

![](./assets/AbstractandFinal_004.png)

Dans une classe qui n'est pas elle-mÃªme finale, vous pouvez dÃ©clarer des mÃ©thodes comme finales. Cela signifie que, mÃªme si la classe peut avoir des sous-classes, la mÃ©thode elle-mÃªme ne peut pas Ãªtre redÃ©finie. Vous pouvez le faire si une mÃ©thode contient un contrÃ´le d'autorisation. Sinon, une sous-classe pourrait redÃ©finir la mÃ©thode et omettre le contrÃ´le d'autorisation.
